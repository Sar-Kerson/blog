# 进程与线程
## 进程
- 孤儿进程: 由于父子进程相互独立，其结束顺序也是未知的。如果父进程先结束，则子进程由init进程接管，该子进程成为孤儿进程，其运行结束后由init回收
- 僵尸进程: 
    - 产生: 当子进程运行结束，并且父进程没有还没回收，该子进程变成僵尸进程，直至父进程调用wait或waitpid回收子进程; 如果没有回收子进程，子进程的状态信息包括进程描述符将保留在内存中，直至重启系统。
    - 危害: 如果父进程代码出现漏洞，导致没有调用wait，那么会产生僵尸进程，如果产生大量僵尸进程的话，一方面占用大量系统资源，严重影响服务器性能; 另一方面pid被占用可能导致无法正常产生新的进程，影响正常服务
    - [避免](https://www.geeksforgeeks.org/zombie-processes-prevention/)
        1. 使用wait系统调用
        2. 忽略SIGCHILD信号。当子进程结束后，会传一个SIGCHILD信号给父进程。如果忽略该信号，则子进程将被系统回收
        3. 使用signal handler, 在handler内部调用wait
        4. [两次fork](https://www.geeksforgeeks.org/double-forking-prevent-zombie-process/): 原因看不太懂...
    ```
    # Fork a second child and exit immediately to prevent zombies.  This
    # causes the second child process to be orphaned, making the init
    # process responsible for its cleanup.  And, since the first child is
    # a session leader without a controlling terminal, it's possible for
    # it to acquire one by opening a terminal in the future (System V-
    # based systems).  This second fork guarantees that the child is no
    # longer a session leader, preventing the daemon from ever acquiring
    # a controlling terminal.
    ```

- TTY: 终端
- PID PGID SID: 
    1. 每个进程属于一个进程组，组号等于组长的PID
    2. 一个进程只能为自己及子进程设置PGID
    3. SID是一组PGID的集合，一个session关系一个tty
    4. 会话中只有组长才能控制tty
- 守护进程、作用及实现
    1. 如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。
    2. 此进程变成该对话期的首进程
    3. 此进程变成一个新进程组的组长进程
    4.  此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。
    5. 为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行

## references
- https://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon
- https://www.geeksforgeeks.org/zombie-processes-prevention/
