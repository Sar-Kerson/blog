# 深入理解计算机系统
## 异常控制流
- 控制流: (a0, a1, ...ak); 控制转移: ai->aj; 异常控制流: ai与aj不相邻。

### 1. 异常
异常就是控制流中的突变，用来响应处理器状态中的某些变化。

- 异常表的实现: 异常表与异常基址寄存器
- 异常的类别: 中断、陷阱、故障、终止

当处理器检测到有事件发生时，会通过一张`异常表`找到对应的处理程序，通过异常来进行处理。处理完成后，根据异常类型，可能有三种返回类型：
1. 返回到当前指令
2. 返回到下一条指令
3. 终止调用程序

*异常与过程调用的区别*
1. 状态保存: 过程调用保存栈帧; 异常保存下一指令地址或当前指令地址
2. 如果控制从用户转移到内核，那么异常的状态信息会保存在内核而不是用户空间
3. 异常处理程序运行在内核态

#### 1. 中断
- 异步发生，是外部信号(终端引脚电压变高)的结果。
- 结束后返回下一条指令$I_{next}$

#### 2. 陷阱
- 同步发生，是当前指令运行的结果(系统调用，如read, write, exit)
- 结束后返回当前指令$I_{current}$

#### 3. 故障(能被故障处理程序修复)
- 同步发生，是当前指令运行的结果，如访问一个未被放入物理内存的页，会触发缺页异常，调度后可以回复运行
- 结束后返回当前指令$I_{current}$

#### 4. 终止
- 将控制返回给一个abort例程，终止程序

### 2. 进程
异常是允许操作系统提供`进程`概念的基本构造块。(进程调度都需要触发异常)

- 逻辑控制流: PC值序列
- 并发流: 流A在流B的开始与结束之间开始
- 私有地址空间: 为什么叫私有，因为A进程的空间不能被B进程访问(读或者写)
- 内核模式与用户模式: **为了限制一个程序可以执行的指令及其能够访问的内存空间范围**。内核模式可以运行任何指令，访问系统中的任何内存位置(上下文切换的前提)
- 上下文: 内核为每个进程维护一个上下文。所谓的上下文就是，内核重新启动一个被抢占的进程所需的状态信息。
- 触发`上下文切换`的例子: 
  1. 系统调用read，read会发生阻塞，因此内核可能发生上下文切换到另一个进程，而不是一直等到IO完成、什么都不做。sleep调用，显式地请求休眠。

![6c633cb9.png](../storage/programming.operation\ system/1fe26192-ac65-4d1d-83f9-7109617c6c52/6c633cb9.png)
```
用户态，进程A，read
->系统调用
->内核态, 上下文切换
->用户态，进程B
->磁盘中断
->内核态，上下文切换
->用户态，进程A，继续执行
```
  2. 定时器中断，会切换到终端处理进程。
- 进程的三种状态，运行，就绪，阻塞
  - [进程的挂起与阻塞](https://blog.csdn.net/paincupid/article/details/51724273): 愚以为，阻塞即遇到某一事件，陷入等待; 挂起则为由于阻塞或者时间片结束原因，被内核换页调出主存
- sleep与pause。sleep请求挂起的秒数。pause使进程挂起直至收到一个信号。

### 3. 信号
信号，是一种软件形式异常，允许进程和内核中断其他进程。

- 发送信号: 内核通过更改目的进程的上下文中某个状态，发送一个信号给目的进程。发送信号有以下两种原因: 
  1. 内核检测到一个系统事件。比如除零错误、子进程终止
  2. 一个进程调用kill，显式地要求内核发信号给目的进程
- 接收信号: 当内核把进程p从内核模式切换到用户模式时，会检查进程的未被屏蔽的待处理信号`pending&(~blocked)`，如果这个集合非空，则触发信号处理。
- 待处理信号: 任何时刻，**每个进程的某种类型信号只有一个待处理信号**。因为，**信号不排队**。举个例子，当前进程接收到信号k，进行处理，同时又接受到n个信号k，那么进程只会有一个待处理信号k，其它n-1个都被丢弃了。
- 阻塞与解除阻塞
  - 隐式阻塞: 如上所述，内核默认阻塞所有正在处理的待处理信号。比如进程正在处理信号s，那么接收到另外一个信号s会变成待处理。
  - 显式阻塞: 使用sigprocmask设置信号屏蔽与解除屏蔽
```
sigprocmask(SIG_BLOCK, &mask, &premask);
//....do something here
sigprocmask(SIG_UNBLOCK, &premask, NULL);
```
- volatile变量。考虑一个处理程序和一个main函数，共享一个全局变量g。如果main周期性读取g，处理程序更新g。对于优化的编译器，g可能没有更新过，因此可能用一个寄存器来缓存g，每次读取g则直接读取寄存器的值。那么volatile告诉编译器不要缓存该值。

#### 信号处理问题
- 待处理信号被阻塞，进程正在处理k类型信号，则此期间收到的k信号会被阻塞
- 待处理信号不会排队，任意类型的信号至多只有一个待处理信号，其他会被丢弃

main

![086349a5.png](../storage/1fe26192-ac65-4d1d-83f9-7109617c6c52/086349a5.png)

handler

![4ae85c7c.png](../storage/1fe26192-ac65-4d1d-83f9-7109617c6c52/4ae85c7c.png)

result
```
hello from child a
hello from child b
hello from child c
handler reaped child
handler reaped child
exit...
```

**问题：信号不会排队，某些信号可能被丢弃。**
- 系统调用可以被中断。像read、write、accept这样的`慢速系统调用`可能被信号中断，**并不会继续运行，而是返回错误，errno被设置为EINTR**

#### 信号处理函数原则
1. 处理程序尽可能简单
2. 在处理程序中只调用异步信号安全函数
3. 保存和回复errno。许多异步信号安全的函数会在出错返回时设置errno，可能会干扰主程序。因此应该备份和恢复errno。
4. 阻塞所有信号，保护对共享数据的访问。
5. 使用volatile生命全局函数，防止优化编译器的缓存。
